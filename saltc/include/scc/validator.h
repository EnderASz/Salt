/**
 * This is the validator module used for validating the generated bytecode.
 *
 *
 * @author bellrise
 */
#ifndef VALIDATOR_H_
#define VALIDATOR_H_

#include <vector>

#include "../utils.h"

namespace salt
{

    enum ValidatorError
    {
        const_string_size,
        const_string_amount,
        instruction_width_violation,
        invalid_const_string_id,
        invalid_data_width,
        invalid_header,
        newline_in_string,
        nonterminated_instruction,
        undeleted_object,
        unknown_id,
    };

    const std::string validator_errors[] {
        "Const string size",
        "Const string amount",
        "Instruction width violation",
        "Invalid const string ID",
        "Invalid data width",
        "Invalid header",
        "Newline in string",
        "Non-terminated instruction",
        "Undeleted object",
        "Unknown ID",
    };

    /**
     * The validator class is used for validating the generated bytecode. This 
     * should be considered as the final step of the whole compilation process,
     * in order to be sure everything was compiled right. 
     *
     * This is a list of checks this validator does:
     *  - const string length
     *  - const string amount
     *  - const string ID calls
     *  - any undeleted objects
     *  - data width
     *  - unknown object IDs 
     *  - max instruction width
     */
    class Validator
    {
    public:

        /* SCC Magic number. */
        const std::string MAGIC = "\x7f\x53\x43\x43\xff\xee\x00\x00";

        /**
         * Explicit validator constructor, initializes the bytecode and loads
         * the contents into it's private memory. Unfortunately building the
         * object isn't really possible with RAII, so there might be a little
         * bit of overhead.
         *
         * @param   bytecode  the whole bytecode that will be pushed to the
         *                    output file  
         */
        explicit Validator(std::string& bytecode);

        /**
         * An alternative for the std::string version, which ultimately ends up
         * calling the std::string version anyway.
         *
         * @param   bytecode  vector of bytes 
         */
        explicit Validator(std::vector<byte>& bytecode);

        /**
         * This adds a function that gets called upon error callback. 
         *
         * @param   __callback  pointer to void (int) function that will get
         *                      called if an error happens during validation.
         */ 
        void setErrorCallback(void (*__callback) (int));

        /**
         * Start the validation process. This will throw a ValidatorError if 
         * something goes wrong, so I recommend creating a try/catch block for
         * this. Note: because validation needs to be one process, fetching
         * data from different parts of the bytecode, it cannot be split into
         * callable functions like isHeaderValid().
         */
        void validate();

    private:

        /**
         * This is the function that actually calls all the checks, so the try 
         * catch block can be located in the validate function.
         */
        void runValidation();

        /**
         * Check the constant string properties, like their length and amount.
         *
         * @return  last position of the constant string section
         * @throw   const_string_size, const_string_amount
         */
        uint checkConstStrings();

        /**
         * Check the magic number at the beggining of the bytecode. This should
         * always be 7f53 4343 ffee 0000.
         *
         * @throw   invalid_header
         */
        void checkMagic();

        /**
         * Check the amount and width of instructions. Starting from the first
         * instruction byte, that is @a __n.
         *
         * @param   __n  start of instruction section
         * @throw   instruction_width_violation
         */
        void checkInstructions(uint __n);

        /**
         * Read the first 64 bytes from the bytecode and load the contents of
         * the header into the member fields.
         *
         * @throw   invalid_header
         */
        void loadHeader();

        /**
         * C-style print @a __n amount of bytes starting from @a __b.
         *
         * @param   __b  pointer to start byte
         * @param   __n  amount of bytes to print
         */
        void printBytes(char *__b, uint __n);

        /**
         * Return the hex value in string form from the passed char.
         *
         * @param   __c character to get
         * @return  0xXX hex stirng representation
         */
        std::string getHex(char __c);

        /**
         * Load 4 bytes from the given pos and return the uint value. This does
         * not change the initial structure of the code.
         *
         * @param   __n  position to fetch the 4 bytes from
         * @throw   invalid_data_width
         */
        uint getUint(uint __n);

        /**
         * Fetch a single instruction starting from @a __n. This will read the
         * bytecode until it finds a newline or the end of the code.
         *
         * @param   __n  position to start reading from
         * @return  whole instruction (without the newline)
         * @throw   nonterminated_instruction
         */
        std::string getInstruction(uint __n);


        bool is_callback_set = false;
        void (*f_callback) (int);

        uint instruction_amount;
        uint cstring_amount;
        uint max_instruction_width;

        std::string bytecode;
        std::vector<uint> object_ids;

    };


} // salt

#endif // VALIDATOR_H_