<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>The SCC3 Standard</title>
    <style>
        body {
            width: 50%;
            margin: auto;
            background-color: whitesmoke;
        }
        .svmcall, .label {
            font-family: monospace;
            background-color: wheat;
            padding: 5px;
            margin-top: 30px;
        }
        .label {
            background-color: rgb(245, 200, 179);
        }
        .struct {
            border-collapse: collapse;
            width: 100%;
            font-family: monospace;
        }
        .struct th, td {
            border: 1px solid #000000;
            padding: 8px;
            text-align: left;
        }
        .struct tr:nth-child(even) {
            background-color: rgb(236, 236, 236);
        }
        .struct tr:hover {
            background-color: rgb(255, 255, 202);
        }
        .byte_list tr td:first-child, .byte_list tr th:first-child {
            width: 10%;
        }
        .grey {
            background-color: lightgray;
            border-radius: 5px;
            padding: 2px;
        }
        #svm_version {
            color: grey;
            font-size: 50%;
        }
    </style>
</head>
<body>
    <h1>
        The SCC3 Standard &nbsp; <a id="svm_version">for SVM 0.10</a>
    </h1>

    <hr>
    <p>
        The Salt programming langauge has to be compiled to a SCC file before it gets executed, to
        increase execution speeds and stability. This is the documentation for the current SCC format
        if you plan to write your own Salt compiler, or just want to tinker with the already produced
        result.
        <br><br>
        Each SVM call (instruction), label & constant string is seperated with the <code>0x0a</code>
        byte, also being the newline ASCII char. In order to still have access to the newline, all
        <code>0x0a</code> bytes in strings must be replaced with <code>0x11</code> bytes, which
        will then get converted to newlines.
        <br><br>
        Because compiled Salt code can be generated by anything and not only the
        <a href="https://github.com/EnderASz/Salt/tree/main/saltc">official compiler</a>, this document
        provides the full list of SVM calls and instructions you can use to make your own Salt compiler.
    </p>
    <hr>

    <h2>SCC Header</h2>
    <p>
        This 64-byte header is located at the beginning of every SCC file, contaning crucial 
        information such as the SCC format version, the magic number, and the amount of instructions.
        Without it, executing Salt would be a lot slower.
    </p>

    <div id="s_header">
        <table class="struct">
            <tr>
                <th>Offset</th>
                <th>Bytes</th>
                <th>Purpose</th>
            </tr>
            <tr>
                <td><code>0</code></td>
                <td><code>7f53 4343 ffee 0000</code></td>
                <td>
                    <code>SCC_HEADER</code>: magic string, indicates that this is indeed a SCC file.
                </td>
            </tr>
            <tr>
                <td><code>8</code></td>
                <td><code>0300 0000 0000 0000</code></td>
                <td>
                    <code>SCC_VERSION</code>: format version (currently 3)
                </td>
            </tr>
            <tr>
                <td><code>16</code></td>
                <td><code>xxxx xxxx 0000 0000</code></td>
                <td>
                    amount of instructions for allocating memory efficiently
                </td>
            </tr>
            <tr>
                <td><code>24</code></td>
                <td><code>xx00 0000 0000 0000</code></td>
                <td>
                    amount of registers allocated for use, can only reach 255 registers
                </td>
            </tr>
            <tr>
                <td><code>32</code></td>
                <td><code>0000 0000 0000 0000<br>0000 0000 0000 0000<br>0000 0000 0000 0000</code></td>
                <td>
                    none
                </td>
            </tr>
            <tr>
                <td><code>56</code></td>
                <td><code>7f7a 7b7c xxxx xx0a</code></td>
                <td>
                    compiler signature - your own signature, it should be unique for each compiler
                </td>
            </tr>
            
        </table>    
    </div>

    <h2>Base types</h2>
    <p>
        These are the basic types the SVM currently accepts.
    </p>

    <div id="s_type">
        <h2 class="wheat"></h2>
        <table class="struct byte_list">
            <tr>
                <th>Byte</th>
                <th>Type</th>
            </tr>
            <tr>
                <td>0x00</td>
                <td>null</td>
            </tr>
            <tr>
                <td>0x01</td>
                <td>int</td>
            </tr>
            <tr>
                <td>0x02</td>
                <td>float</td>
            </tr>
            <tr>
                <td>0x03</td>
                <td>bool</td>
            </tr>
            <tr>
                <td>0x04</td>
                <td>string</td>
            </tr>
        </table>
    </div>

    <h2>Payload</h2>
    <p>
        The payload "type" is a way of passing raw values to instructions. Because different
        types have different sizes of information, it needs to be specified before.
    </p>

    <div id="s_payload">
        <h2 class="wheat"></h2>
        <table class="struct">
            <tr>
                <th>Type</th>
                <th>Bytes</th>
                <th>Additional information</th>
            </tr>
            <tr>
                <td>null</td>
                <td>-</td>
                <td>No bytes represent the null type</td>
            </tr>
            <tr>
                <td>int</td>
                <td>xxxx</td>
                <td>The value of the integer is stored in litte-endian arranged 4 bytes</td>
            </tr>
            <tr>
                <td>float</td>
                <td>xxxx</td>
                <td>Same as the int, 4 byte little endian alignment</td>
            </tr>
            <tr>
                <td>bool</td>
                <td>x</td>
                <td>0x01 for true, 0x00 for false</td>
            </tr>
            <tr>
                <td>string</td>
                <td>xxxx[...]0x00</td>
                <td>The first four bytes are the length of the string given in a little-endian
                unsigned int. This value should be equal to the amount of characters in the string
                + 1 for the null byte. Note that each 0x0a byte should be replaced with a 0x11 byte
                as you might need </td>
            </tr>
        </table>
    </div>

    <h2>Using the dynamic model object list & registers</h2>

    <p>
        Every object that is expected to have a certain lifetime should be put on the module
        specific object list, which is often called "the tape". Most operations will happen
        using objects on the tape, because most instructions require you to pass the ID of
        said object which can only be located on the tape. Because this list is dynamic and
        a lot of lookups have to be done to access any object, it is a good idea to use
        <b>registers</b> for small, local operations. These are much faster to access and use
        because of the static length of the register array, defined in the header. If you're
        writing a compiler with dynamic object linking avaible, you don't have to worry about
        the amount of registers. When loading a new module, the amount is read from the header
        and compared to the current amount. If the amount exceeds the current amount of registers,
        it allocates more space.
        <br><br>
        You can access these registers using both <code><a href="#s_rgpop">RGPOP</a></code>
        and <code><a href="#s_rpush">RPUSH</a></code> to read & write values.
        <br><br>
        Note that changes have been made in SVM version 0.10 to speed up the object tape.
        Now, object lookups start from the newest to the oldest object, which makes adding
        and removing objects in a single subroutine fast, even if total amount of allocated 
        memory is high.
        <br><br>
        Because each tape is available globally for the object it's currently in, <b>function
        scopes do not exist.</b> Variable availability has to be handled by the compiler,
        creating and unlinking objects at the correct moment.
    </p>

    <h4>Good practices for writing your own Salt compiler</h4>
    <ol>
        <li>Delete locally declared variables in the same scope</li>
        <li>Pass function arguments into registers, and then load them back in the function</li>
    </ol>

    <br><hr>

    <h2>Labels</h2>
    <p>
        Each label always begins with an <code>@</code> sign, letting the virtual machine know
        to add the line to the module label map.
    </p>

    <div id="s_$__init__">
        <h2 class="label">@$__INIT__</h2>
        <p>
            Starting point of the program. This is called a label, which the Virtual
            Machine can jump to.
        </p>
    </div>
    
    <div id="s_$__end__">
        <h2 class="label">@$__END__</h2>
        <p>
            End label. When the SVM hits this line, it calls <code>core_clean()</code> and exits the program.
        </p>
    </div>

    <div id="s_else">
        <h2 class="label">@#</h2>
        <p>
            This label shows the next closes jump-to location if the if statement returns
            false. This is used in the virtual machine to make quick and efficient jumps
            to a further point in code, because the jump instructions only have to find
            one char in the instruction.
        </p>
    </div>

    <div id="s_function">
        <h2 class="label">@function</h2>
        <p>
            Any other label is that doesn't start with a <code>$</code> nor a <code>#</code>
            sign is considered a function label, which you can jump to using
            <code><a href="#s_callf">CALLF</a></code> or <code><a href="#s_callx">CALLX</a></code>.
        </p>
    </div>

    <hr>
    <h2>SVM Calls</h2>
    <p>
        This is a list of SVM calls you can make in the latest format.
    </p>

    <div id="s_callf">
        <h2 class="svmcall">CALLF strl ...</h2>
        <p>
            Call a function and push the current position and call onto the stack pointer.
            Note that this only works for local functions in the same module, and should be
            used when possible because it's a lot faster than the alternative,
            <code><a href="s_callx">CALLX</a></code>.
        </p>
        <table class="struct">
            <tr>
                <th>Offset</th>
                <th>Width</th>
                <th>Type</th>
                <th>What</th>
            </tr>
            <tr>
                <td>0</td>
                <td>4</td>
                <td>uint</td>
                <td>string length</td>
            </tr>
            <tr>
                <td>4</td>
                <td>...</td>
                <td>string</td>
                <td>null terminated string</td>
            </tr>
        </table>
    </div>


    <div id="s_exite">
        <h2 class="svmcall">EXITE</h2>
        <p>
            Exit the current executed module. This is the safe version of
            <code><a href="#s_killx">KILLX</a></code>, because it jumps to the <code>$__END__</code>
            label and leaves <code>exec</code> to pop everything from the stack and finish execution.
            This is different to said kill instruction, which immediately collapses the module tapes
            and exits the program.
        </p>
    </div>

    <div id="s_extld">
        <h2 class="svmcall">EXTLD string</h2>
        <p>
            Load an external SCC file and add it to the global module register.
        </p>
        <table class="struct">
            <tr>
                <th>Offset</th>
                <th>Width</th>
                <th>Type</th>
                <th>What</th>
            </tr>
            <tr>
                <td>0</td>
                <td>n</td>
                <td><a href="#s_payload">payload</a>[string]</td>
                <td>Name of the external library. Cannot have the <code>.scc</code> extension
                because it is added later in the SVM when actually reading the file.</td>
            </tr>
        </table>
    </div>

    <div id="s_killx">
        <h2 class="svmcall">KILLX</h2>
        <p>
            Kill the whole program on-the-spot. This tried to free any memory it can as fast
            as possible, and this kills the whole program. Note that this almost certainly
            produce unwanted memory leaks, so it's recommended not to use it.
        </p>
    </div>

    <div id="s_mlmap">
        <h2 class="svmcall">MLMAP</h2>
        <p>
            Map the object tape in the current module. This will dump the whole list of stored
            objects. May be used for debugging.
        </p>
    </div>

    <div id="s_objmk">
        <h2 class="svmcall">OBJMK id readonly type ...</h2>
        <p>
            Create a new object in the current module. This should be handled by an
            external function in the compiler, to always get it right because it's a
            quite complex instruction.
        </p>
        <table class="struct">
            <tr>
                <th>Offset</th>
                <th>Width</th>
                <th>Type</th>
                <th>What</th>
            </tr>
            <tr>
                <td>0</td>
                <td>4</td>
                <td>uint</td>
                <td>Object ID</td>
            </tr>
            <tr>
                <td>4</td>
                <td>1</td>
                <td>byte</td>
                <td>Read-only: if the variable is constant</td>
            </tr>
            <tr>
                <td>6</td>
                <td>1</td>
                <td>byte</td>
                <td>Type of the object, one of Synthesize::TYPE_</td>
            </tr>
            <tr>
                <td>7</td>
                <td>-</td>
                <td><a href="#s_payload">payload</a></td>
                <td>The value of the new object</td>
            </tr>
        </table>
    </div>

    <div id="s_objdl">
        <h2 class="svmcall">OBJDL id</h2>
        <p>
            Delete the object in the current module. This doesn't actually remove the object
            from memory, but signs it as "inactive". The virtual machine decides when to actually
            free the memory and remove the object permanently.
        </p>
        <table class="struct">
            <tr>
                <th>Offset</th>
                <th>Width</th>
                <th>Type</th>
                <th>What</th>
            </tr>
            <tr>
                <td>0</td>
                <td>4</td>
                <td>uint</td>
                <td>Object ID</td>
            </tr>
        </table>
    </div>


    <div id="s_print">
        <h2 class="svmcall">PRINT id</h2>
        <p>
            Print the value of the object (without a newline). Most prints require a newline
            anyway, so it is a good idea for the compiler to create a readonly string with only
            a newline character, and chain the <code>PRINT object</code> & <code>PRINT const_newline</code>.
        </p>
        <table class="struct">
            <tr>
                <th>Offset</th>
                <th>Width</th>
                <th>Type</th>
                <th>What</th>
            </tr>
            <tr>
                <td>0</td>
                <td>4</td>
                <td>uint</td>
                <td>Object ID</td>
            </tr>
        </table>
    </div>

    <div id="s_retrn">
        <h2 class="svmcall">RETRN</h2>
        <p>
            Return from the current function, popping a function off the callstack.
        </p>
    </div>

    <div id="s_rgpop">
        <h2 class="svmcall">RGPOP register id</h2>
        <p>
            Move the value from the register onto the module object list, making it an object
            with a set ID. Note that this does not remove any previous objects with the same IDs from
            the list, but adds a brand new object at the beginning.
            <br><br>
            The max amount of registers if defined in the SCC header.
        </p>
        <table class="struct">
            <tr>
                <th>Offset</th>
                <th>Width</th>
                <th>Type</th>
                <th>What</th>
            </tr>
            <tr>
                <td>0</td>
                <td>1</td>
                <td>byte</td>
                <td>Register ID</td>
            </tr>
            <tr>
                <td>1</td>
                <td>4</td>
                <td>uint</td>
                <td>Object ID</td>
            </tr>
        </table>
    </div>

    <div id="s_rpush">
        <h2 class="svmcall">RPUSH register id</h2>
        <p>
            Set the value of the given register to the selected object by ID. Important note: this
            removes the original object from the module object list, assigning it only to the register.
            <br><br>
            The max amount of registers if defined in the SCC header.
        </p>
        <table class="struct">
            <tr>
                <th>Offset</th>
                <th>Width</th>
                <th>Type</th>
                <th>What</th>
            </tr>
            <tr>
                <td>0</td>
                <td>1</td>
                <td>byte</td>
                <td>Register ID</td>
            </tr>
            <tr>
                <td>1</td>
                <td>4</td>
                <td>uint</td>
                <td>Object ID</td>
            </tr>
        </table>
    </div>

    <footer style="height: 100px;"></footer>

</body>
</html>