<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SCC Documentation</title>
    <style>
        body {
            width: 50%;
            margin: auto;
            background-color: whitesmoke;
        }
        .svmcall, .label {
            font-family: monospace;
            background-color: wheat;
            padding: 5px;
            margin-top: 30px;
        }
        .label {
            background-color: rgb(245, 200, 179);
        }
        .struct {
            border-collapse: collapse;
            width: 100%;
            font-family: monospace;
        }
        .struct th, td {
            border: 1px solid #000000;
            padding: 8px;
            text-align: left;
        }
        .struct tr:nth-child(even) {
            background-color: rgb(236, 236, 236);
        }
        .struct tr:hover {
            background-color: rgb(255, 255, 202);
        }
        .byte_list tr td:first-child, .byte_list tr th:first-child {
            width: 10%;
        }
        .grey {
            background-color: lightgray;
            border-radius: 5px;
            padding: 2px;
        }
    </style>
</head>
<body>
    <h1>
        Salt Compiled Code (scc3) documentation
    </h1>

    <hr>
    <p>
        The Salt programming langauge is compiled to a SCC file before it gets executed, to
        increase execution speeds and stability, because the compiled does a lot of validation
        checks. This is the list of all current svm calls & labels.
        <br>
        Each SVM call (instruction), label & constant string is seperated with the <code>0x0a</code>
        byte, also being the newline ASCII char. In order to still have access to the newline, all
        <code>0x0a</code> bytes in strings must be replaced with <code>0x11</code> bytes, which
        will then get converted to newlines.
        <br>
        Important note: <b>all object IDs created by the user must start from <code>0800 0000</code>
        (8)</b>. The first 8 object IDs are reserved by the SVM. Assigning an object to these
        reserved IDs may cause unexpected problems.
    </p>
    
    <h2>SCC Header</h2>
    <p>
        This 64-byte header is located at the beginning of every SCC file, contaning crucial 
        information such as the SCC format version, the magic number, the amount of instructions
        or const strings. Without it, executing Salt would be a lot harder.
    </p>

    <div id="s_header">
        <table class="struct">
            <tr>
                <th>Offset</th>
                <th>Bytes</th>
                <th>Purpose</th>
            </tr>
            <tr>
                <td><code>0</code></td>
                <td><code>7f53 4343 ffee 0000</code></td>
                <td>
                    <code>SCC_HEADER</code>: magic string, indicates that this is indeed a SCC file.
                </td>
            </tr>
            <tr>
                <td><code>8</code></td>
                <td><code>0300 0000 0000 0000</code></td>
                <td>
                    <code>SCC_VERSION</code>: format version
                </td>
            </tr>
            <tr>
                <td><code>16</code></td>
                <td><code>xxxx xxxx 0000 0000</code></td>
                <td>
                    amount of instructions for allocating memory efficiently
                </td>
            </tr>
            <tr>
                <td><code>24</code></td>
                <td><code>0000 0000 0000 0000<br>0000 0000 0000 0000<br>0000 0000 0000 0000<br>0000 0000 0000 0000</code></td>
                <td>
                    none
                </td>
            </tr>
            <tr>
                <td><code>56</code></td>
                <td><code>7f7a 7b7c xxxx xx0a</code></td>
                <td>
                    compiler signature
                </td>
            </tr>
            
        </table>    
    </div>
    
    <h2>Base types</h2>
    <p>
        These are the basic types the SVM currently accepts. You should use
        <code class="grey">salt::Synthesizer::TYPE_xxx</code> in the compiler
        instead of raw bytes as this <i>might</i> change in the future.
    </p>

    <div id="s_type">
        <h2 class="wheat"></h2>
        <table class="struct byte_list">
            <tr>
                <th>Byte</th>
                <th>Type</th>
            </tr>
            <tr>
                <td>0x00</td>
                <td>null</td>
            </tr>
            <tr>
                <td>0x01</td>
                <td>int</td>
            </tr>
            <tr>
                <td>0x02</td>
                <td>float</td>
            </tr>
            <tr>
                <td>0x03</td>
                <td>bool</td>
            </tr>
            <tr>
                <td>0x04</td>
                <td>string</td>
            </tr>
        </table>
    </div>

    <br><hr>
    <h2>Payload</h2>
    <p>
        The payload "type" is a way of passing raw values to instructions. Because different
        types have different sizes of information, it needs to be specified before.
    </p>

    <div id="s_payload">
        <h2 class="wheat"></h2>
        <table class="struct">
            <tr>
                <th>Type</th>
                <th>Bytes</th>
                <th>Additional information</th>
            </tr>
            <tr>
                <td>null</td>
                <td>-</td>
                <td>No bytes represent the null type</td>
            </tr>
            <tr>
                <td>int</td>
                <td>xxxx</td>
                <td>The value of the integer is stored in litte-endian arranged 4 bytes</td>
            </tr>
            <tr>
                <td>float</td>
                <td>xxxx</td>
                <td>Same as the int, 4 byte little endian alignment</td>
            </tr>
            <tr>
                <td>bool</td>
                <td>x</td>
                <td>0x01 for true, 0x00 for false</td>
            </tr>
            <tr>
                <td>string</td>
                <td>xxxx[...]0x00</td>
                <td>The first four bytes are the length of the string given in a little-endian
                unsigned int. This value should be equal to the amount of characters in the string
                + 1 for the null byte. Note that each 0x0a byte should be replaced with a 0x11 byte
                as you might need </td>
            </tr>
        </table>
    </div>

    <br><hr>

    <h2>Labels</h2>

    <div id="s_$__init__">
        <h2 class="label">@$__INIT__</h2>
        <p>
            Starting point of the program. This is called a label, which the Virtual
            Machine can jump to.
        </p>
    </div>
    
    <div id="s_$__end__">
        <h2 class="label">@$__END__</h2>
        <p>
            End label. When the SVM hits this line, it calls <code>core_clean()</code> and exits the program.
        </p>
    </div>

    <div id="s_else">
        <h2 class="label">@$ELSE</h2>
        <p>
            This label shows the next closes jump-to location if the if statement returns
            false. This is used in the virtual machine to make quick and efficient jumps
            to a further point in code, because all the locations of the else tags are
            preloaded before execution. This allows to use a binary search algorithm to
            find the closest jump.
        </p>
    </div>

    <hr>
    <h2>SVM Calls</h2>
    <p>
        This is a list of SVM calls you can make in the latest format. Note that the
    </p>


    <div id="s_callf">
        <h2 class="svmcall">CALLF strl ...</h2>
        <p>
            Call a function and push the current position and call onto the stack pointer.
            Note that this only works for local functions in the same module, and should be
            used when possible because it's a lot faster than the alternative,
            <code><a href="s_callx">CALLX</a></code>. The only argument is the label name,
            so if you want to call a function rendered as <code>@function_name</code>, you
            call: <code>CALLFxxxxxxxxfunction_name\0</code>.
        </p>
        <table class="struct">
            <tr>
                <th>Offset</th>
                <th>Width</th>
                <th>Type</th>
                <th>What</th>
            </tr>
            <tr>
                <td>0</td>
                <td>uint</td>
                <td>uint</td>
                <td>string length</td>
            </tr>
            <tr>
                <td>4</td>
                <td>...</td>
                <td>string</td>
                <td>null terminated string</td>
            </tr>
        </table>
    </div>


    <div id="s_exite">
        <h2 class="svmcall">EXITE</h2>
        <p>
            Exit the current executed module.
        </p>
    </div>

    <div id="s_extld">
        <h2 class="svmcall">EXTLD string</h2>
        <p>
            Load an external SCC file and add it to the global module register.
        </p>
        <table class="struct">
            <tr>
                <th>Offset</th>
                <th>Width</th>
                <th>Type</th>
                <th>What</th>
            </tr>
            <tr>
                <td>0</td>
                <td>n</td>
                <td><a href="#s_payload">payload</a>[string]</td>
                <td>Name of the external library. Cannot have the <code>.scc</code> extension
                because it is added later in the SVM when actually reading the file.</td>
            </tr>
        </table>
    </div>

    <div id="s_killx">
        <h2 class="svmcall">KILLX</h2>
        <p>
            Kill the whole program on-the-spot. This tried to free any memory it can as fast
            as possible, and this kills the whole program. Note that this almost certainly
            produce unwanted memory leaks, so it's recommended not to use it.
        </p>
    </div>

    <div id="s_objmk">
        <h2 class="svmcall">OBJMK id readonly type threaded ...</h2>
        <p>
            Create a new object in the current module. This should be handled by an
            external function in the compiler, to always get it right because it's a
            quite complex instruction.
        </p>
        <table class="struct">
            <tr>
                <th>Offset</th>
                <th>Width</th>
                <th>Type</th>
                <th>What</th>
            </tr>
            <tr>
                <td>0</td>
                <td>4</td>
                <td>uint</td>
                <td>Object ID</td>
            </tr>
            <tr>
                <td>4</td>
                <td>1</td>
                <td>byte</td>
                <td>Read-only: if the variable is constant</td>
            </tr>
            <tr>
                <td>6</td>
                <td>1</td>
                <td>byte</td>
                <td>Type of the object, one of Synthesize::TYPE_</td>
            </tr>
            <tr>
                <td>7</td>
                <td>1</td>
                <td>byte</td>
                <td>If the object should be thread-compatible, one of Synthesize::THREADED_</td>
            </tr>
            <tr>
                <td>8</td>
                <td>-</td>
                <td><a href="#s_payload">payload</a></td>
                <td>The value of the new object</td>
            </tr>
        </table>
    </div>

    <div id="s_objdl">
        <h2 class="svmcall">OBJDL id</h2>
        <p>
            Delete the object in the current module. This doesn't actually remove the object
            from memory, but signs it as "inactive". The virtual machine decides when to actually
            free the memory and remove the object permanently.
        </p>
        <table class="struct">
            <tr>
                <th>Offset</th>
                <th>Width</th>
                <th>Type</th>
                <th>What</th>
            </tr>
            <tr>
                <td>0</td>
                <td>4</td>
                <td>uint</td>
                <td>Object ID</td>
            </tr>
        </table>
    </div>


    <div id="s_print">
        <h2 class="svmcall">PRINT id</h2>
        <p>
            Print the value of the object (without a newline). Most prints require a newline
            anyway, so it is a good idea for the compiler to create a readonly string with only
            a newline character, and chain the <code>PRINT object</code> & <code>PRINT const_newline</code>.
        </p>
        <table class="struct">
            <tr>
                <th>Offset</th>
                <th>Width</th>
                <th>Type</th>
                <th>What</th>
            </tr>
            <tr>
                <td>0</td>
                <td>4</td>
                <td>uint</td>
                <td>Object ID</td>
            </tr>
        </table>
    </div>

    <div id="s_retrn">
        <h2 class="svmcall">RETRN</h2>
        <p>
            Return from the current function, popping a function off the callstack.
        </p>
    </div>

    <footer style="height: 100px;"></footer>

</body>
</html>