<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Salt bytecode</title>
    <style>
        #main {
            border-collapse: collapse;
            width: 100%;
        }
        #vars {
            border-collapse: collapse;
        }
        tr:first-child {
            font-family: monospace;
        }
        th, td {
            border: 1px solid black;
            text-align: left;
            padding: 8px;
        }
        tr:nth-child(even) {
            background-color: whitesmoke;
        }
        tr:hover {
            background-color: wheat;
        }
    </style>
</head>
<body>
    <h2>Salt bytecode documentation</h2>

    <p>
        This is a full list of the newest Salt Virtual Machine instruction list with
        arguments and explanations for each of them. Each executable instruction is <b>exactly
        5 characters long</b>. A instruction that begins with a <code>@</code> sign is
        a label the virtual machine can jump to.
    </p>

    <table id="vars">
        <tr>
            <th>Variable</th>
            <th>Replacement</th>
        </tr>
        <tr>
            <td><code>ARGS</code></td>
            <td><code>({r1:basetype *:typename *:name}+ | .)</code></td>
        </tr>
        <tr>
            <td><code>VAR</code></td>
            <td><code>r1:basetype *:typename *:value</code></td>
        </tr>
        <tr>
            <td><code>BASIC</code></td>
            <td><code>r1:basetype *:value</code></td>
        </tr>
    </table>

    <br>

    <table id="main">
        <tr>
            <th>Instruction</th>
            <th>Arguments</th>
            <th>Explanation</th>
        </tr>
        <tr>
            <td><code>@$__INIT__</code></td>
            <td>-</td>
            <td>
                Starting point of the program. This is called a label, which the Virtual
                Machine can jump to. The initial dollar ($) sign makes the label a unique
                label which there can only be one of.
            </td>
        </tr>
        <tr>
            <td><code>@$__END__</code></td>
            <td>-</td>
            <td>
                End of the program. When encountering this statement, the Virtual Machine
                cleans the callstack and frees all the heap data. After that, it exits the
                program.
            </td>
        </tr>
        <tr>
            <td><code>@ELSE</code></td>
            <td>-</td>
            <td>
                This label shows the next closes jump-to location if the if statement returns
                false. This is used in the virtual machine to make quick and efficient jumps
                to a further point in code, because all the locations of the else tags are
                preloaded before execution. This allows to use a binary search algorithm to
                find the closest jump.
            </td>
        </tr>
        <tr>
            <td><code>RETRN</code></td>
            <td><code>(VAR)</code></td>
            <td>
                This instruction is located at the end of every function, even if the user
                did not define so. This sends a <code>CSPOP</code> signal to the virtual machine,
                popping one element off the callstack and returning to the previous scope.
            </td>
        </tr>
        <tr>
            <td><code>IMPRT</code></td>
            <td><code>s:lib</code></td>
            <td>
                Import module and define it as accessable though a global variable
                with the same name as `lib`.
            </td>
        </tr>
        <tr>
            <td><code>MKVAR</code></td>
            <td><code>s:varname (VAR)</code></td>
            <td>
                Make variable. Create a variable in the current scope with the specified
                value. If `basetype` is not 1, use `typename` to define what unit this variable
                is using. If `basetype` is 0, use the base simple types defined in typename 
                which is then only 1 byte wide.
            </td>
        </tr>
        <tr>
            <td><code>STVAR</code></td>
            <td><code>s:varname (VAR)</code></td>
            <td>
                Set the passed variable name to the selected var. Type checking is done on the
                compiler stage, so the virtual machine doesn't have to worry it 
            </td>
        </tr>
        <tr>
            <td><code>DLVAR</code></td>
            <td><code>s:varname</code></td>
            <td>
                Delete variable. This deletes the global instance of the variable, making
                all future calls to the variable throw a NullPointerException.
            </td>
        </tr>
        <tr>
            <td><code>MKFUN</code></td>
            <td><code>r1:accessl s:funcname i:args (ARGS) r1:basetype *:typename</code></td>
            <td>
                Create function. `accessl` can be either 0 for public or 1 for private. 
                The `args` is the amount of variables that will be found. If this is 0, 
                the proceeding token will be a single dot. Else each variable will be 
                defined as a type and value pair.
            </td>
        </tr>
        <tr>
            <td><code>DLFUN</code></td>
            <td><code>s:funcname</code></td>
            <td>
                Delete function. Deletes the global function label which will cause
                all later function calls throw a NullPointerException for this function.
                This is used for optimalization, this shouldn't be placed by the user
                coding a Salt program, but is placed by the compiled when no further
                calls to this function are found. This helps lower memory usage.
            </td>
        </tr>
        <tr>
            <td><code>MKUNT</code></td>
            <td><code>r1:accessl s:unitname i:fields (ARGS)</code></td>
            <td>
                Create a unit from the specifed access level, unitname and fields.
            </td>
        </tr>
        <tr>
            <td><code>CALLF</code></td>
            <td><code>s:funcname i:args (ARGS)</code></td>
            <td>
                Call the function creating a new scope on the callstack.
            </td>
        </tr>
        <tr>
            <td><code>CALLX</code></td>
            <td><code>s:libname s:funcname i:args (ARGS)</code></td>
            <td>
                Call an external function from the imported library. Throws exceptions if
                fails to find function.
            </td>
        </tr>
        <tr>
            <td><code>SLEEP</code></td>
            <td><code>i:miliseconds</code></td>
            <td>
                Pause this thread for the given amount of miliseconds.
            </td>
        </tr>
        <tr>
            <td><code>THROW</code></td>
            <td>-</td>
            <td>
                Artificially throw an exception. This will then exit the thread deconstructing
                the callstack while doing so. This will use <code>__SVM_ERRNO__</code> for the 
                error ID (which error to throw) and <code>__SVM_ERRSTR__</code> for the error
                message.
            </td>
        </tr>
        <tr>
            <td><code>IFNUL</code></td>
            <td><code>(BASIC)</code></td>
            <td>
                Comparison. If x == 0. 
            </td>
        </tr>
        <tr>
            <td><code>IFSML</code></td>
            <td><code>(BASIC) (BASIC)</code></td>
            <td>
                Comparison. If x &lt; y. 
            </td>
        </tr>
        <tr>
            <td><code>IFSME</code></td>
            <td><code>(BASIC) (BASIC)</code></td>
            <td>
                Comparison. If x &lt;= y. 
            </td>
        </tr>
        <tr>
            <td><code>IFLGE</code></td>
            <td><code>(BASIC) (BASIC)</code></td>
            <td>
                Comparison. If x >= y. 
            </td>
        </tr>
        <tr>
            <td><code>IFLRG</code></td>
            <td><code>(BASIC) (BASIC)</code></td>
            <td>
                Comparison. If x > y. 
            </td>
        </tr>
        <tr>
            <td><code>IFEQU</code></td>
            <td><code>(BASIC) (BASIC)</code></td>
            <td>
                Comparison. If x == y. 
            </td>
        </tr>
        <tr>
            <td><code>FILOP</code></td>
            <td><code>s:varname s:filename i:mode</code></td>
            <td>
                Open a file and assign the file handle to the given variable. Throws
                <code>FileException</code> if no such file is found, is already open
                or cannot be opened1
            </td>
        </tr>
        <tr>
            <td><code>FILCL</code></td>
            <td><code>i:handle</code></td>
            <td>
                Close the passed file handle. Throws <code>FileException</code> if no such
                file is open.
            </td>
        </tr>
        <tr>
            <td><code>FILRD</code></td>
            <td><code>s:varname i:amount i:handle</code></td>
            <td>
                Read n amount of bytes from the handle. Throws <code>StreamException</code>
                if it tries to read <code>EOF</code>, is in the incorrect mode or is closed.
            </td>
        </tr>
        <tr>
            <td><code>FILWT</code></td>
            <td><code>i:handle i:amount s:string</code></td>
            <td>
                Write n amount of bytes from the string to the file. Throws <code>StreamException</code>
                if the system runs out of space, the file is closed or is open in the wrong mode.
            </td>
        </tr>
    </table>

</body>
</html>