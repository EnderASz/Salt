<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SVM Documentation</title>
    <style>
        body {
            width: 50%;
            margin: auto;
            background-color: whitesmoke;
        }
        h2 {
            font-family: monospace;
            background-color: wheat;
            padding: 5px;
        }
        .struct {
            border-collapse: collapse;
            width: 100%;
            font-family: monospace;
        }
        .struct th, td {
            border: 1px solid black;
            padding: 8px;
            text-align: left;
        }
        .struct tr:nth-child(even) {
            background-color: rgb(236, 236, 236);
        }
        .struct tr:hover {
            background-color: rgb(255, 255, 202);
        }
    </style>
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
</head>
<body>
    <h1>
        Salt Virtual Machine (svm) documentation
    </h1>
    
    <hr>
    <p>
        The Salt Virtual Machine is the interpreter for compiled Salt code generated by <code>saltc</code>,
        the Salt compiler. It is written in C to have more control over the bytes and what is happening
        in the background, to achieve better execution speeds. This documentation page contains information
        about global types, #defines and structures along with enums.
    </p>

    <!-- ### HEADER SPLIT ### -->
    <h1>core.h</h1>
    <hr>

    <div id="s_ARCH">
        <h2>#define ARCH</h2>
        <p>
            Architecture the program is compiled on. On Windows this is usually set to
            32-bit by default, so to properly align structures you need to add padding
            depending if the pointer size is 8 bytes or 4 bytes. Also, sucks to be a MacOs
            user because SVM doesn't support it. too bad!
        </p>
    </div>

    <div id="s_SCC_HEADER_MAGIC">
        <h2>#define SCC_HEADER_MAGIC</h2>
        <p>
            These header defines are used for validating the SCC header. These contain
            important information such as the magic number & the SCC format version.
        </p>
    </div>
    
    <div id="s_SCC_HEADER_VERSION">
        <h2>#define SCC_HEADER_VERSION</h2>
        <p>
            These header defines are used for validating the SCC header. These contain
            important information such as the magic number & the SCC format version.
        </p>
    </div>
    
    <div id="s_CORE_ERROR">
        <h2>macro CORE_ERROR()</h2>
        <p>
            Core error macro, print the error message and exit.
        </p>
    </div>
    
    <div id="s_byte">
        <h2>typedef byte</h2>
        <p>
            <code>unsigned char</code>
        </p>
    </div>

    <div id="s_FLAG_HELP">
        <h2>char FLAG_HELP</h2>
        <p>
            Help page flag.
        </p>
    </div>

    <div id="s_salt_id_counter">
        <h2>uint salt_id_counter</h2>
        <p>
            Global ID of salt objects. The initial value of this is 100, leaving space
            for system variables ranging from 0 to 100.
        </p>
    </div>

    <div id="s_svm_instructions">
        <h2>uint svm_instuctions</h2>
        <p>
            The amount of instructions core_load_bytecode needs to allocate space for.
            This helps to speed up the compiler to not overallocate nor underallocate,
            so it's generally faster and more memory efficient.
        </p>
    </div>

    <div id="s_svm_const_strings">
        <h2>uint svm_const_strings</h2>
        <p>
            The amount of constant strings the vm needs to allocate space for. Again, 
            this is for optimazation.
        </p>
    </div>
    
    <div id="s_svm_max_width">
        <h2>uint svm_max_width</h2>
        <p>
            Maximum width of a single instruction provided by the compiler.
        </p>
    </div>

    <div id="s_salt_id">
        <h2>uint salt_id()</h2>
        <p>
            Get a unique ID for every newly created object.
        </p>
    </div>

    <div id="s_core_parse_args">
        <h2>char *core_parse_args(2)</h2>
        <p>
            Parse the command line arguments and set special flags defined here so they
            can be accessed anywhere.
        </p>
    </div>

    <div id="s_core_show_help">
        <h2>void core_show_help()</h2>
        <p>
            Show the help page and exit the program.
        </p>
    </div>

    <div id="s_core_load_header">
        <h2>void core_load_header(1)</h2>
        <p>
            Read & load the header file contents to the global variables. While reading,
            validate information in the header and optionally exit the program with a
            fatal error if something is incorrect.
        </p>
    </div>

    <div id="s_core_load_bytecode">
        <h2>char **core_load_bytecode(1)</h2>
        <p>
            Read & load the bytecode from the scc file. This must be executed after
            core_load_header, because of the global variables it sets and also moves the
            file cursor 64 bytes forward.
        </p>
    </div>

    <!-- ### HEADER SPLIT ### -->
    <h1>object.h</h1>
    <hr>

    <div id="s_SaltObject">
        <h2>struct SaltObject (_salt_object_st)</h2>
        <p>
            The SaltObject structure type is a universal data container used everywhere
            in Salt to hold any type of data. This is achieved by leaving space for a void
            pointer, which you can then dereference to get the data.
        </p>
        <table class="struct">
            <tr>
                <th>Field</th>
                <th>Size</th>
                <th>Purpose</th>
            </tr>
            <tr>
                <td>uint id</td>
                <td>4</td>
                <td>unique ID of the object assigned by salt_id()</td>
            </tr>
            <tr>
                <td>byte type</td>
                <td>1</td>
                <td>base type of the object. should be one of SaltType_</td>
            </tr>
            <tr>
                <td>byte permission</td>
                <td>1</td>
                <td>0x00 if SVM Core created this object</td>
            </tr>
            <tr>
                <td>byte constant</td>
                <td>1</td>
                <td>0x01 if the variable is constant</td>
            </tr>
            <tr>
                <td>byte typeinfo[8]</td>
                <td>8</td>
                <td>additional information about the type</td>
            </tr>
            <tr>
                <td>void *data</td>
                <td>8</td>
                <td>pointer to the actual data</td>
            </tr>
            <tr>
                <td>uint mutex_id</td>
                <td>4</td>
                <td>ID of the mutex. if no mutex is locking this, it is set to 0x00</td>
            </tr>
            <tr>
                <td>uint scope_id</td>
                <td>4</td>
                <td>ID of the scope where the variable is visible</td>
            </tr>
        </table>
    </div>

    <div id="s__salt_object_create">
        <h2>static SaltObject _salt_object_create(8)</h2>
        <p>
            The full method for creating a brand new Salt Object. Defines all the fields
            which it can assign to. This method is private because it should be called
            using other wrapper functions that are much easier to use.
        </p>
    </div>

    <div id="s_salt_object_mkconst">
        <h2>SaltObject salt_object_mkconst(3)</h2>
        <p>
            Create a new constant variable from the passed information.
        </p>
    </div>

    <footer style="height: 100px;"></footer>

</body>
</html>